---
layout: post
title:  "一些计算机基础知识问答"
subtitle: '面试准备'
date:   2020-07-22 12:00:21 +0800
tags: 面试
color: rgb(255,90,90)
cover: '../assets/20200720/'
---

## **进程、线程、协程之间的区别**

**对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。**

### **进程**
进程是正在运行的程序的实例，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动

### **线程**
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。

线程拥有自己的栈空间，是程序的执行者。

### **协程**
协程是一种用户级的轻量级线程。

协程不被操作系统内核所管理，由程序完全控制（工作在用户态）

### **区别**
多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大

多进程中某一进程出错不会影响其他进程，而多线程中某一线程出错会影响其他线程

进程之间不共享全局变量，线程之间共享全局变量

多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行

协程的资源开销要小于线程

协程的本质是单线程，无法利用多核CPU的优势

## **输入网址访问一个网站的全过程**

1. DNS解析
   
   将域名解析为目的ip地址

2. 建立TCP连接
   
3. 浏览器向服务器发送http请求

4. 服务器处理http请求，并回复

4. 浏览器解析渲染服务器http回复

## **什么是http**
http叫做超文本传输协议，是一个属于应用层的面向对象的协议，它规定了浏览器和web服务器之间相互通信的规则。

http每次连接只处理一个请求和响应，对每一个页面的访问，浏览器与web服务器都要建立一次单独的连接

http1.1相对于http1.0，允许浏览器在拿到当前请求对应的全部资源后再断开连接，提高了效率

一个完整的http请求包括：
* 请求行
* 首部（若干消息头）
* 实体内容（可无）

例如：
``` 
//请求行
POST /books/java.html HTTP/1.1
//首部
Accept:*/*
Accept-Language:en-us
Connection:Keep-Alive
Host:localhost
Referer:http://localhost/links.jsp
User-Agent:Mozilla/4.0
Accept-Encoding:gzip,deflate

//实体内容，与消息头之间有一个空行
name=tom&password=123
```

请求行用于描述客户端的请求方式，请求资源名称，以及使用的HTTP协议版本号

首部用于描述客户端请求哪台主机，以及客户端的一些环境信息

一个http响应包括
* 状态行
* 首部（若干消息头）
* 实体内容

状态行用于描述服务器对请求的处理结果

首部用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理回送的数据

试题内容代表服务器向客户端回送的数据

常用**通用首部**
| 代码 | 说明 |
| ---- | ---- |
| Cache-Control | 控制缓存的行为 |
| Connection | 控制不再转发给代理的首部字段、管理持久连接，即完成后连接是否保持 |
| Date | 创建报文的日期时间 |
| Pragma | 报文指令 |
| Trailer | 报文末端的首部一览 | 
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade | 升级为其他协议 |
| Via | 代理服务器的相关信息 |
| Warning | 错误通知 | 

常用**请求首部**
| 代码 | 说明 |
| ---- | ---- |
| Accept:text/html,image/* | 支持的数据类型 |
| Accept-Charset:utf-8 | 支持的数据的编码字符集 |
| Accpet-Encoding:gzip | 支持的压缩方式 |
| Accept-Language:en-us,zh-cn | 支持的语言 |
| Host:localhost:8888 | 请求的主机名 |
| Referer:http://www.it315.org/index.jsp | 发送请求的界面对应的url |
| User-Agent: Mozilla/4.0 | http客户端程序相关信息 |
| Authorization | Web 认证信息 |
| Expect | 期待服务器的特定行为 |
| From | 用户的电子邮箱地址 |
| If-Match | 比较实体标记（ETag） |
| If-Modified-Since | 比较资源的更新时间 |
| If-None-Match | 比较实体标记（与 If-Match 相反） |
| If-Range | 资源未更新时发送实体 Byte 的范围请求 |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards | 最大传输逐跳数 |
| Proxy-Authorization | 代理服务器要求客户端的认证信息 |
| Range | 实体的字节范围请求 |
| TE | 传输编码的优先级 |

常用**响应首部**
| 代码 | 说明 |
| ---- | ---- |
| Accept-Ranges | 是否接受字节范围请求 |
| Age | 推算资源创建经过时间 |
| ETag | 资源的匹配信息 |
| Location | 令客户端重定向至指定 URL |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After | 对再次发起请求的时机要求 |
| Server | HTTP 服务器的安装信息 |
| Vary | 代理服务器缓存的管理信息 |
| WWW-Authenticate | 服务器对客户端的认证信息 |

常用**实体首部**
| 代码 | 说明 |
| ---- | ---- |
| Allow | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言 |
| Content-Length | 实体主体的大小 |
| Content-Location | 替代对应资源的 URL |
| Content-MD5 | 实体主体的报文摘要 |
| Content-Range | 实体主体的位置范围 |
| Content-Type | 实体主体的媒体类型 |
| Expires | 实体主体过期的日期时间 |
| Last-Modified | 资源的最后修改日期时间 |


## **http的安全性问题**
http协议属于明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题

## **http状态码**
### **1XX**

信息性状态码，接受的请求正在处理
* **100 Continue：**表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应

### **2XX**
成功状态码，请求正常处理完毕
* **200 OK：** 成功处理了请求
* **204 No Content：**请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用
* **206 Partial Content：**表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容

### **3XX**
重定向状态码，需要进行附加操作以完成请求
* **301 Moved Permanently：**永久性重定向
* **302 Found：**临时性重定向
* **303 See Other：**和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源
* **304 Not Modified：**如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码
* **307 Temporary Redirect：**临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法

### **4XX**
客户端错误状态码，服务器无法处理请求
* **400 Bad Request：**请求报文中存在语法错误
* **401 Unauthorized：**该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
* **403 Forbidden：**请求被拒绝
* **404 Not Found：**找不到请求的资源

### **5XX**

* **500 Internal Server Error：**服务器正在执行请求时发生错误
* **503 Service Unavailable：**服务器暂时处于超负载或正在进行停机维护，现在无法处理请求


## **什么是https**
HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

## **https如何实现安全性**
HTTPS 采用**混合的加密机制**，使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。

通过使用**证书**来对通信方进行认证。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人发送的伪造证书，不能够获得CA的认证，此时，客户端和服务器就知道通信被劫持了。

即 **非对称加密算法（公钥和私钥）交换对称密钥**+**数字证书验证身份（验证公钥是否是伪造的**）+**利用对称密钥加解密后续传输的数据**

SSL 提供报文摘要功能来进行完整性保护。HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。

## **介绍http指令**
**请求方式**包括：
* **GET**

  用于向服务器获取信息，可以携带参数，所携带信息通常不能超过4K，不适用于提交大量表单数据

* **POST**
  
  用于向服务器发送数据，将请求参数放在请求体中，并非URL之后，发送的数据大小无限制

* **HEAD**
  
  获取报文首部，主要用于确认URL的有效性以及资源更新的日期时间等

* **PUT**
  
  用于上传文件，自身不带验证机制，存在安全性问题

* **PATCH**
  
  对资源进行部分修改

* **DELETE**
  
  用于删除文件，自身不带验证机制

* **OPTIONS**

  查询指定的URL能够支持的方法

* **CONNECT**

  要求在与代理服务器通信时建立隧道，使用SSL和TLS协议把通信内容加密后经网络隧道传输

* **TRACE**

  追踪路径，服务器会将通信路径返回给客户端

## **GET和POST的区别**
GET 用于获取资源，而 POST 用于传输实体主体

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

GET是幂等的，而POST不是。

## **进程间通信的方式**
1. **无名管道**
   
   管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；

   管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）

   一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。管道大小约64k

2. **有名管道**
   
   有名管道不同于无名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中，因此参与的进程不必具有亲缘关系，只要可以访问该路径，就能通信，有名管道仍然是半双工，管道大小约64k

3. **信号方式**
   
   通过信号发出和捕捉信息通信

4. **消息队列方式**

   单一消息队列依旧无法双向传输，且消息队列随内核持续，是有限资源，单个大小约为16k

5. **共享内存方式**

   最快的方式，映射一段能被其他进程所访问的内存
   
   为避免同时写共享内存发生混乱，可设置主人标志位进行指导操作

6. **Unix套接字方式**

   可实现双向通信，与TCP套接字不同为协议模式不同，一个是网络传输，一个是本地传输，Unix域可以设置阻塞和非阻塞方式，使用select控制读写

7. **文件锁方式**

8. **信号量**
   
   信号量是一个计数器，可以用来控制多个进程对共享资源的访问。


## 解释物理内存

## 解释虚拟内存

## 堆和栈的区别

## 什么是多态

## 重载和重写的区别

## 返回值是否能重载

## 虚函数和纯虚函数的区别

## 介绍智能指针

## 数组和链表的区别

## 介绍单例模式

## 介绍lambda表达式

## 析构函数为什么是虚函数

## 容器迭代器，插入删除时迭代器的状态（顺序容器、无序容器）

## 生产者消费者模型，多个生产者，一个消费者，消费者无法访问队列时该怎么办

## 一个程序突然崩溃该怎么处理

## socket绑定0.0.0.0，127.0.1.1的意义

## 使用UDP如何实现可靠传输

## ip包如何辨别tcp和udp

## tcp为什么是三次握手、四次挥手
三次握手，是为了防止已失效的连接请求报文段突然又传送到了服务端从而导致错误。

四次挥手，是因为TCP是全双工的，当c发出FIN报文表示无数据待发送时，s依旧可以向c发送数据，只有s向c发送ack确认报文时，才表示s知道了c没有数据要发。而s没有数据要发送时也要向c发送FIN报文，同理C也要回复ack报文表示知晓，这样才能断开连接

## 调用纯虚函数会发生什么

## 子类重写纯虚函数实在什么时候进行覆盖的

## 写一个析构函数不是纯虚函数的类，会发生什么错误

## HashMap和数组的区别

## tcp报文头有什么

## 分页管理和分段管理

## 四层网络协议

## 应用层有什么协议

## 传输层有什么协议

## 为什么要使用不安全的UDP

## Out of memory发生的区域

## 调用方法过多，哪个部分会报异常

## 进程调度算法

## 什么是死锁，以及产生条件

## 如何预防死锁

## OSI七层模型

## malloc和new的区别/free和delete的区别

## STL库用过哪些数据结构

## LRU实现方式

## 并行并发区别

## tcp如何分配报文序号

## 内核态和用户态

## 介绍redis

## 介绍栈溢出

## 介绍数据库索引

## 逻辑地址如何转为物理地址

## MySQL内部数据的组织方式

## 面向对象语言的特点

## map的底层实现

## set的特点

## 线程有什么执行方式

## C++内存分布

## TCP如何进行流量控制


**参考资料**

> https://blog.csdn.net/weixin_43870646/article/details/86575142
> https://blog.csdn.net/weixin_42157608/article/details/80362542
> https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E7%BC%93%E5%AD%98
> https://blog.csdn.net/xiaoming100001/article/details/81109617


